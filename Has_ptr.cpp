#include "Has_ptr.h"

// Инициализация статического члена класса
size_t numbered::cnt = 0;

// ПРИМ: Синтезируемый конструктор копирования поэлементно копирует НЕСТАТИЧЕСКИЕ переменные-члены объкетов,
// вызывая оператор = для соотвествующих типов (встроенных или классов)
Has_ptr::Has_ptr(const Has_ptr& h)
{
	// копирование объекта в НОВУЮ выделенную память, а не копирование указателя (как в поведении синтезируемой версии)
	std::string str = *(h.ps);
	ps = new std::string(str);
	i = h.i;
	std::cout << MODULE_NAME << "Copy Constructor called" << std::endl;
}

// ПРИМ: Синтезируемый оператор присвоения присваивает значение каждой НЕСТАТИЧЕСКОЙ переменной-члена правого объекта
// соответсвующей переменной-члену левого объекта с использованием оператора присвоения копии = типа этой переменной
Has_ptr& Has_ptr::operator= (const Has_ptr& rhs) 
{
	std::string str = *(rhs.ps);
	ps = new std::string(str);
	i = rhs.i;

	std::cout << MODULE_NAME << "Custom operator= called" << std::endl;

	return *this;
}

// ПРИМ: Правило три\пять: если классу нужен деструктор, то нужны и конструктор-копирования и оператор присвоения
// Если нужен конструктор-копирования, то понадобится и  оператор присвоения и наоборот. Однако деструктор тогда необязателен
Has_ptr::~Has_ptr() 
{ 
	delete(ps); // если бы использовилсь синтезируемые конструктор копирования или оператор присвоения, происходило бы
				// многократное освобождения памяти по одному и тому же указтелю (ОШИБКА)
	std::cout << MODULE_NAME << "Custom Destructor called" << std::endl; 
}
