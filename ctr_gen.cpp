#include <iostream>
#include <string>

using namespace std;


// Rules of Constructors generation. 


class Person
{
public:

	// If custom Ctr provided - default Ctr omitted
	Person(const string &s): name(s) {}

	// Not generated by compiler bacause of another custom Ctr.
	/* Person() = default; */

	// Custom Dtr
	~Person(){ cout << "~Person()" << endl; }

	// Custom copy Ctr
	// Person(const Person &rhs): name(rhs.name) { cout << "Person Copy Ctr" << endl; }

	// Generated by compiler even if custom Dtr provided.
	/* Person(const Person &rhs) = default; */
	/* Person& operator= (const Person &rhs) = default;
 
	// С++ 11 не генерирует операции перемещения для класса с пользовательским 
	// деструктором. Таким образом, перемещающие операции генерируются 
	// (при необходимости) для классов, только если выполняются три следующие условия:
	// • в классе не объявлены никакие копирующие операции;
	// • в классе не объявлены никакие перемещающие операции;
	// • в классе не объявлен деструктор.

	// Not generated.
	/* Person(Person &&rhs) nexcept = default; */
	/* Person& operator= (Person &&rhs) noexcept = default; */

	string get_name() const { return name; }

private:
	string name;
};

// Рекомендация о большой тройке:
// если вы объявили хотя бы одну из трех операций 
// - копирующий конструктор, 
// - копирующий оператор присваивания или 
// - деструктор, 
// то вы должны объявить все три операции.




void tests()
{
	/* Person p1; */	// ERROR - no default Ctr provided

	Person p2("mik");
	Person p3("bob");

	// OK - copy operations is generated even if custom Dtr exists
	p3 = p2;			

	// OK - move operations hasn't been generated, copy Ctr will be called instead.
	Person p4(std::move(p3));

	cout << "p3.name after move: "<< p3.get_name() << endl; // Hasn't been moved actually
}


int main()
{
	tests();

	return 0;
}