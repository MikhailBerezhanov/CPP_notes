
#include <iostream>

#include "exercises.h"

// Константные выражения constexpr: возвращаемый тип и тип каждого параметра должны быть литералами 
// и return может быть только один
/*constexpr*/ int const_init() { return 10; }

constexpr size_t scale(size_t cnt) { return 50 * cnt;}	// константное выражение, если cnt - константное выражение

int a;	// в глобальной области видимости объект встроенного типа инициализируется 0, но не в локальной
//const int c ;	// ОШИБКА: Необходима инициализация константы
extern const int c = 1; // для совместного использования констант в файлах программы необходим extern в объявлении

int main(int argc, char* argv[]) 
{ 

	unsigned u = 10 , u2 = 42 ;
	std::cout << u2 - u << std::endl;	// 32
	std::cout << u - u2 << std::endl;	// 32 mod 4 294 967 296 = 4 294 967 264
	int i = 10 , i2 = 42;
	std::cout << i2 - i << std::endl;	// 32
	std::cout << i - i2 << std::endl;	// -32
	std::cout << i - u << std::endl;	// 0
	std::cout << u - i << std::endl;	// 0
	std::cout << "balbalbalabla "  
	"babaopdofpso" << std::endl;
	std::cout << 0x000C << std::endl;


	int i3 = 1.111;	// 1
	int i4 = {i3};	// Инициализация с проверкой допустимости значения
	//double *dp = &i3, dp2 = {"avc"};	ОШИБКА инициализации


	int var = 5;
	int* ip = &var, *&r = ip;	// ссылка на указатель
	std::cout << "ip: "<<  *ip << " r: "<< r << " *r: "<< *r << std::endl;
	// ПРИМ. Указатель на ссылку не сущесствует т.к. ссылка - не объект в отличие от указателя


	double dval = 3.14;
	// создается временная переменная и ссылка связывается с temp (3)( const int temp = dval; )
	// без const была бы ошибка т.к. тогда был бы доступ на изменение временной переменной
	const int &ri = dval;
	std::cout << "ri: " << ri << std::endl;


	const int ic=0, &rc = 0, *pc;
	//int *const ptr;  		ОШИБКА: Необходима инициализация константного указателя
	//const int &const r2;	ОШИБКА: Необходима инициализация ссылки
	int a = -1;
	const int a2 = a, &ra = a;
	// ПРИМ. Константная ссылка (указатель) определяет только набор доступных операция по ссылку (указателю)
	// Сам объект на который ссылаются (указывают) может быть неконстантным и изменяться напрямую. 


	// ПРИМ. Преобразование не константы в константу возможно, но не наоборот
	const int *p1, b = 1;
	int *const p2 = nullptr;	// nullptr - литеральная константа, означающая нулевой указатель
	p1 = p2;
	//int &rb = b;		 	ОШИБКА


	constexpr int ce = 20;		// константное выражение (инициализируется во время компиляции и просто подставляется значение)
	const int c = const_init();	// неконстантное выражение т.к. инициализация происходит во время выполнения, а не компиляции.
								// такие функции должны быть простыми чтобы компилятор мог выполнять их во время компиляции.
	//constexpr int ce = const_init(); // ОШИБКА: функция объявлена без модификатора constexpr
	constexpr int *q = nullptr; // Константный указатель ( int *const q )
	// ПРИМ. constexpr можно определить только для литеральных типов, не для собственных вроде классов,
	// Для указателей и ссылок constexpr используется ВНЕ любых функций, т.к.определенные в функции переменные 
	// не хранятся по определенному адресу. Адрес переменной должен быть фиксированным (если внутри ф-ии то static)
	//constexpr int *q1 = &a;	ОШИБКА: a определена внутри функции ( на стеке ) 
	constexpr int *q2 = &::a;	// OK: ::а - обращение к глобально объявленной переменной 


	auto ai = 0, *pa = &ai;		// ai - int, pa - int* (auto - int)
	//auto aj = 0, pj = 3.14;	// ОШИБКА: несовместимые типы (auto - становится сначала int , затем double)
	auto ac = ce;				// auto - int , const верхнего уровня отбрасывается
	ac = 10;
	auto acp = p1, acpe = &ce;	// auto - const int* , const нижнего уровня сохраняется
	//*acp =10;	 ОШИБКА: нельзя изменять константу
	const auto accp = a;		// auto - const int
	const auto &ar = 42;


	// decltype определяет типо , но не инициализирует переменную значением.
	// decltype не отбрасывает const верхнего уровня
	decltype(const_init()) x1 = 33.3;	// x - int , т.к. функция имеет возвращаемое значение этого типа.
	std::cout << "x1: " << x1 << std::endl;	// 33
	//decltype(ce) x2;		ОШИБКА: константа должна быть инициализирована
	//decltype(ra) x3;		ОШИБКА: ссылка должна быть инициализирована
	// decltype возвращает ссылочный тип для выражений, результатомкоторых являются объекты, способные стоять 
	// лева от оператора присвоения. Некоторые выражения заставят возвращать ссылочный тип. 
	decltype(ra + 0) x4;	// ra - int& , но сложение возвращает тип int 
	//decltype(*q) x5; 		ОШИБКА: ссылка должна быть инициализирована ( получился ссылочный тип int& )
	decltype((a)) da = a;	// () - выражение, возвращающее ссылочный тип, da - ссылка на a


	struct Sales_data{
		std::string book_no;		// используется инициализатор по-умолчанию - ""
		unsigned units_sold = 0;	// внутриклассовый инициализатор
		double revenue {0.1};		// внутриклассовый инициализатор
	};
	using Sd = Sales_data;
	const Sd obj;	// ОК т.к. Sales_data имеет инициализаторы
	//constexpr Sales_data obj;	ОШИБКА: Sales_data не литерального типа (ни арифметический, ни указатель, ни ссылка)
	std::cout << "Sales_data obj: '" << obj.book_no << "' " << obj.units_sold << " " << obj.revenue << std::endl;	


	using std::endl; using std::cout;
	// ПРИМ. Не рекомендуется включать using в хедеры, т.к. текст хедера вставляется в исходник 
	// и может привести к нежелательному включению пространства имен
	cout << "No std needed, Hooray!" << endl;


	//chapter3();

	//chapter4();

	//chapter5();

	//chapter6();

	//chapter7();

	//chapter8();

	//chapter9();

	//chapter10();

	//chapter11();

	//chapter12();

	//chapter13();

	chapter14();

	return 0;
}

// [1,9,2,8,3,7] -> [1,2,3,7,8,9]
// [(1),2,9,3,<8,7>]
// [1,(2),8,9,<3,7>]
// [1,2,(3),8,<9,7>]
// [1,2,3,(7),<8,9>]
// [1,2,3,7,8,9]

// Пузырьковая сортировка O((n^2-n)/2)
void bubble_sort(int* arr, size_t len)
{	
	for(int i = 0; i < len-1; ++i){
		// за проход вытолкнуть самый маленький в начало
		for(int j = len-1; j > i; --j){

			if(arr[j] > arr[j-1]){
				int tmp = arr[j];
				arr[j] = arr[j-1];
				arr[j-1] = tmp;
			}
		}
	}
}

// проходим набор во внутреннем цикле и определяем новое значение - начало
	
// [(1),<9>,2,8,3,7]
// [1,(9),<2>,8,3,7]
// [1,2,(9),<8>,3,7]
// [1,2,3,(8),<9>,7]
// [1,2,3,7,(9),<8>]
// [1,2,3,7,8,9]

// Сортировка выбором (выборками)  O((n^2-n)/2)  но меньше обменов чем в пузырьке
void select_sort(int* arr, size_t len)
{
	int first = arr[0];
	int idx = 0;
	bool swap = false;

	for(int i = 0; i < len-1; ++i){

		first = arr[i];
		swap = false;

		for(int j = i+1; j < len; ++j){

			if(arr[j] < first){
				first = arr[j];
				idx = j;
				swap = true;
			}

		}

		if(swap){
			arr[idx] = arr[i];
			arr[i] = first;
		}
	}
}

// <-- Сортируется в начало
// [<1>,(9),2,8,3,7]  	->кэш  (9)
// [<1>,(9),2,8,3,7]  	<-вставка (9) (положение не изменилось)

// [1,<9>,(2),8,3,7]  	->кэш  (2)
// [1,<9>,*9,8,3,7]
// [<1>,2,9,8,3,7]  	<-вставка (2) в отсортированную последовательность

// [1,2,<9>,(8),3,7]  	->кэш  (8)
// - аналогично  2 -

// [1,2,8,<9>,(3),7]  	->кэш  (3) 
// [1,2,<8>,9,*9,7]
// [1,<2>,8,*8,*9,7]
// [<1>,2,3,8,9,7]  	<-вставка (3) в отсортированную последовательность

// [1,2,3,8,<9>,(7)]
// [1,2,3,7,8,9]

// Сортировка вставками
// 1. количество сравнений в сортировке вставками зависит от
// изначальной упорядоченности списка (поведение естественно)
// 2. не меняет порядок одинаковых ключей
void insert_sort(int* arr, size_t len)
{
	int insert_elem, b;

	for(int a = 1; a < len; ++a){

		insert_elem = arr[a];

		// ищем куда вставить очередной эл-т. если цикл законечен, то вставляем
		for(b = a-1; b >= 0 && insert_elem < arr[b]; --b){
			arr[b+1] = arr[b];	// раздвижение отсортированной части
		}

		// вставка очередного эл-та в отсортированную последовательность 
		// (или сохранение положения если не было ниодной итерации)
		arr[b+1] = insert_elem;
	}
}