#include <iostream>
#include <string>
#include <set>
#include <chrono>

using namespace std;

multiset<string> names;

// function with direct argument passing 
// by universal reference usage
template<typename T>
void log_and_add(T &&name)
{
	// do log
	auto time = std::chrono::system_clock::now();

	// update global container
	// NOTE: using emplace to pass name directly to the
	// std::string constructor instead of creating temp object
	// while inserting
	names.emplace( std::forward<T>(name) );
}

// 1. Problem with overloads

// overloading for integers
void log_and_add(int idx)
{
	names.emplace("name_from_index");
}


void log_and_add_test()
{	
	string s{"mik"};
	short name_idx = 110;

	log_and_add("name1");	// OK - called uni ref version (direct std::string constuctor call)
	log_and_add(s);			// OK - called uni ref version (lvalue ref - string copy ctr)
	log_and_add(string("temp"));	// OK (rvalue passed - string move ctr called)

	log_and_add(15);		// OK - called int version

	//log_and_add(name_idx);	// ERROR - called uni ref version as best candidate 
							// T = short  VS  short to int 
							// no std::string constructor accepts short

	// NOTE: uni ref is greedy when overloads take place. 
	// T&& can represent any type and may be best candidate
	// while types deduction in most cases. No overloads of 
	// uni ref function is recommended!
}


// 2. Problem with constructors

class Person
{
public:

	// Constructor with direct argument passing
	// NOTE: can be instantiated as copy or move constructor
	// Person(Person &rhs) , Person(Person &&rhs)
	template <typename T>
	explicit Person(T &&str): name(std::forward<T>(str)) {}

	explicit Person(int idx): name("name_from_index") {}

	// Generated by compiler:
	// Person(const Person &rhs): name(rhs.name) {}
	// Person(Person &&rhs): name(std::move(rhs)) {}

private:
	string name;
};

void person_test()
{
	Person p("Daria");

	// uni ref constructor will be instantiated as
	//
	// 		explicit Person(Person &str)
	//

	//Person copy_p(p); 	// ERROR - uni ref contructor called. 
						// No std::string constructor accepts Person& .
						// Copy constructor not called, because lvalue p is not const

	const Person p2("Mik");

	// uni ref constructor will be instantiated as
	//
	// 		explicit Person(const Person &str)
	//
	// BUT
	//
	// Одно из правил разрешения перегрузок в С++ гласит, что в ситуации,
	// когда инстанцирование шаблона и нешаблонная функция (т.е."нормальная" функция) 
	// имеют одинаково хорошее соответствие, предпочтение отдается нормальной функции.
	// Поэтому все козыри оказываются на руках копирующего конструктора 
	// (нормальной функции) с той же самой сигнатурой.

	Person copy_p2(p2);	// OK - copy constructor called
}


// 3. Problem with inheritance

class SpecialPerson : public Person
{
public:
	// Copy constructor
	//SpecialPerson(const SpecialPerson &rhs): Person(rhs) {}

	// Move constructor
	//SpecialPerson(SpecialPerson &&rhs): Person(std::move(rhs)) {}

	// Will not be compiled bacause instead of calling copy \ move 
	// constructors of base class, uni ref contructor would be called
	// with argument SpecialPerson !
};



int main()
{
	log_and_add_test();
	
	person_test();

	return 0;       
}