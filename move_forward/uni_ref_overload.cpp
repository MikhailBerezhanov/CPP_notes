#include <iostream>
#include <string>
#include <set>
#include <chrono>
#include <utility>	// std::forward, std::remove_reference, 
#include <type_traits>
					// std::true_type, std::false_type
					// std::is_integral, std::is_same, std::is_base_of
					// another template functions

using namespace std;

multiset<string> names;

// function with direct argument passing 
// by universal reference usage
template<typename T>
void log_and_add(T &&name)
{
	// do log
	auto time = std::chrono::system_clock::now();

	// update global container
	// NOTE: using emplace to pass name directly to the
	// std::string constructor instead of creating temp object
	// while inserting
	names.emplace( std::forward<T>(name) );
}

// 1. Problem with overloads

// overloading for integers
void log_and_add(int idx)
{
	names.emplace("name_from_index");
}


void log_and_add_test()
{	
	string s{"mik"};
	short name_idx = 110;

	log_and_add("name1");	// OK - called uni ref version (direct std::string constuctor call)
	log_and_add(s);			// OK - called uni ref version (lvalue ref - string copy ctr)
	log_and_add(string("temp"));	// OK (rvalue passed - string move ctr called)

	log_and_add(15);		// OK - called int version

	//log_and_add(name_idx);	// ERROR - called uni ref version as best candidate 
							// T = short wins  VS  short_to_int conversion
							// no std::string constructor accepts short

	// NOTE: uni ref is greedy when overloads take place. 
	// T&& can represent any type and may be best candidate
	// while types deduction in most cases. No overloads of 
	// uni ref function is recommended!
}


// 2. Problem with constructors

class Person
{
public:

	// Constructor with direct argument passing
	// NOTE: can be instantiated as copy or move constructor
	// Person(Person &rhs) , Person(Person &&rhs)
	template <typename T>
	explicit Person(T &&str): name(std::forward<T>(str)) {}

	explicit Person(int idx): name("name_from_index") {}

	// Generated by compiler:
	// Person(const Person &rhs): name(rhs.name) {}
	// Person(Person &&rhs): name(std::move(rhs)) {}

private:
	string name;
};

void person_test()
{
	Person p("Daria");

	// uni ref constructor will be instantiated as
	//
	// 		explicit Person(Person &str)
	//

	//Person copy_p(p); 	// ERROR - uni ref contructor called. 
						// No std::string constructor accepts Person& .
						// Copy constructor not called, because lvalue p is not const

	const Person p2("Mik");

	// uni ref constructor will be instantiated as
	//
	// 		explicit Person(const Person &str)
	//
	// BUT
	//
	// Одно из правил разрешения перегрузок в С++ гласит, что в ситуации,
	// когда инстанцирование шаблона и нешаблонная функция (т.е."нормальная" функция) 
	// имеют одинаково хорошее соответствие, предпочтение отдается нормальной функции.
	// Поэтому все козыри оказываются на руках копирующего конструктора 
	// (нормальной функции) с той же самой сигнатурой.

	Person copy_p2(p2);	// OK - copy constructor called
}


// 3. Problem with inheritance

class SpecialPerson : public Person
{
public:
	// Copy constructor
	//SpecialPerson(const SpecialPerson &rhs): Person(rhs) {}

	// Move constructor
	//SpecialPerson(SpecialPerson &&rhs): Person(std::move(rhs)) {}

	// Will not be compiled bacause instead of calling copy \ move 
	// constructors of base class, uni ref contructor would be called
	// with argument SpecialPerson !
};



// Possible solutions:
// 1. Do not use overloads for functions with universal reference parameter(s).
//    (use different names for functions with different parameters types:
// 		log_and_add_name(), log_and_add_name_index() ). 
// 	  But this approach will not work with contsructors, bacuse it's name is
//	  fixed.
//
// 2. Use argument passing by value:
class Person2
{
public:
	explicit Person2(string s): name(std::move(s)) {} 

	explicit Person2(int idx): name("name_from_index") {}

	// const char* and string objects will call Person(string s) Ctr
	// size_t , short, long , etc.. will call Person(int) Ctr

	// But no direct passing advantages works =(

private:
	string name;
};

// 3. Descriptors dispatching (Диспетчеризация декстрипторов)
// - use additional function parameter for correct overload deduction
//

// Declaration of new version
template <typename T>
void log_and_add_fixed(T &&);

// Worker function Implementation
//
// значения true и false являются значениями времени выполнения, а нам 
// для выбора верной версии log_and_add_impl необходимо разрешение перегрузки, 
// т.е. явление времени компиляции. 
// Это означает, что нам нужен тип, соответствующий значению true, и другой тип, 
// соответствующий значению false . Такая необходимость - настолько распространенное 
// явление, что стандартная библиотека предоставляет то, что нам нужно, 
// под именами std::true_tуре и std::false_type.
template <typename T>
void log_and_add_impl(T &&name, std::false_type)
{
	// not integer param passed

	// do log
	auto time = std::chrono::system_clock::now();
	
	names.emplace( std::forward<T>(name) );
}

void log_and_add_impl(int idx, std::true_type)
{
	// just chooses name from integer index
	log_and_add_fixed("name_from_index");
}

template <typename T>
void log_and_add_fixed(T &&uni_ref_param)
{
	// deligate execution to emplementation
	log_and_add_impl( 
		std::forward<T>(uni_ref_param), 

		// NOTE: if lvalue int was passed to function ParamType 
		// will be lvalue ref (int&) and will not be intergal type.
		std::is_integral<
			//typename std::remove_reference<T>::type
			// C++14 style
			std::remove_reference_t<T>
		>()
	);

	// std::is_integral :
	// Checks whether T is an integral type. Provides the member 
	// constant value which is equal to true, if T is the type bool, 
	// char, char8_t (since C++20), char16_t, char32_t, wchar_t, short, int, 
	// long, long long, or any implementation-defined extended integer types, 
	// including any signed, unsigned, and cv-qualified variants. Otherwise, 
	// value is equal to false. 
}


void log_and_add_fixed_test()
{
	char cval = 9;
	short sval = 199;
	double dval = 10.11;	// is not integral

	string name("mik");

	// Client code doesn't changed
	log_and_add_fixed(name);	// OK - uses uni ref version

	log_and_add_fixed(10);		// OK - uses integral version

	log_and_add_fixed(cval);	// OK
	log_and_add_fixed(sval);	// OK

	// log_and_add_fixed(dval);	// ERROR - not std::string Ctr takes double
}

// This approach is based on not overloaded client API ( log_and_add_fixed() ).
// Overload takes place only in implementation function. 
//
// So, problem for constructors with direct passing stays the same: 
// compilers generate copy and move contructors that may overload direct passing 
// contructor. Even if descriptors dispatching will be done for direct passing
// constructor, generated constructors may be called as best candidates.
// (see problems 2 and 3).
//
// 4. In such cases std::enable_if for constructor template can be used.

class Person_fixed
{
public:

	// "SFINAE" - технология позволяет работать std::еnаblе_if

	// Шаблон с прямой передачей, включающийся по условиям
	//   только если тип Т не является Person_fixed или порожденным от него (производным)
	//   И Т не является целочисленным типом.
	//
	// - Для вызовов с аргументами типа Person_fixed шаблон будет отключаться и
	//   использоваться будут сгенерированные компилятором копирующий или перемещающий
	//   конструторы (const Person_fixed&, Person_fixed&&)
	//
	// - Для вызовов с целочисленными агрументами шаблон будет отключаться и 
	//   использоваться будет его перегрузка принимающая int idx.
	//

	// Если разобраться, что означает, что шаблонный конструктор в классе Person должен
	// быть включен только тогда, когда Т не является Person_fixed, то мы поймем, что, 
	// глядя на Т, мы хотим игнорировать следующее.
	// • Ссылки. С точки зрения определения, должен ли быть включен конструктор с уни­
	//   версальной ссылкой, типы Person_fixed, Person_fixed& и Person_fixed&& должны 
	//   рассматриваться как идентичные типу Person_fixed.
	// • Модификаторы const и volatile. С той же точки зрения типы const Person_fixed,
	//   volatile Person_fixed и const volatile Person должны рассматриваться как 
	//   идентичные типу Person_fixed.
	// 
	// Для такого поведения существует std::decay. Тип std::decay<T>::type
	// представляет собой то же самое, что и тип Т, но из него удалены все 
	// ссылки и квалификаторы const и volatile.


	// Применение std::еnаblе_if не влияет на реализацию функции. 
	// Реализация остается той же. Добавляется допонительный параметр шаблона.
	//
	//	typename = typename std::enable_if< условие >::type 
	//

	template<
		typename T,
		typename = typename std::enable_if<  
			!std::is_base_of< Person_fixed, 
							  typename std::decay<T>::type 
							>::value
			&&
			!std::is_integral< typename std::remove_reference<T>::type >::value 
		>::type 
	>
	explicit Person_fixed(T &&param): name(std::forward<T>(param)){}

	// Значение std::is_base_of< T1, T2 >::value истинно, если Т2 - класс, 
	// производный от T1 . Пользовательские типы рассматриваются как производные от 
	// самих себя, так что std::is_base_of< T, Т >::value истинно, если Т представляет 
	// собой пользовательский тип. (Если Т является встроенным типом,
	// std::is_base_of< T, T >::value ложно.)


	explicit Person_fixed(int idx): name("name_from_index") {}

	Person_fixed() = default;

	//
	// Generated copy and move constructors
	//

private:
	string name;
};


class SpecialPerson_fixed final : public Person_fixed
{
public:

	SpecialPerson_fixed(): Person_fixed() {}

	// Теперь при передаче SpecialPerson_fixed для инициализации базовой части
	// производного класса  НЕ будет вызываться конструктор с прямой передачей,
	// а будут вызваны сгенерированные конструкторы копирования \ перемещения. 

	SpecialPerson_fixed(const SpecialPerson_fixed &rhs): Person_fixed(rhs) {} // OK!

	SpecialPerson_fixed(SpecialPerson_fixed &&rhs): Person_fixed(std::move(rhs)) {} // OK! 
};

void person_fixed_test()
{
	// Direct passing Ctr
	Person_fixed pf("mik");	

	string name = "bob";
	Person_fixed pf2(name);
	Person_fixed pf3(std::move(name));

	// Direct passing Ctr disabled
	Person_fixed pf_copy(pf3);				// Copy Ctr called
	Person_fixed pf_move(std::move(pf));	// Move Ctr called

	Person_fixed pf5(10);
	short sval = 123;
	char cval = 15;
	Person_fixed pf6 = Person_fixed(sval);	// OK 
	Person_fixed pf7(cval);

	// Derived class test
	SpecialPerson_fixed spf;
	// Direct passing Person_fixed::Ctr disabled - copy and move Ctrs called
	SpecialPerson_fixed spf_copy(spf);
	SpecialPerson_fixed spf_move(std::move(spf));
}


int main()
{
	/// Problems demonstration

	log_and_add_test();
	
	person_test();


	// Solutions

	log_and_add_fixed_test();

	person_fixed_test();

	return 0;       
}