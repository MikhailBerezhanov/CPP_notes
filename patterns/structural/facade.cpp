#include <iostream>
#include <memory>
#include <string>

using namespace std;

// Фасад — это структурный паттерн проектирования, который предоставляет 
// простой интерфейс к сложной системе классов, библиотеке или фреймворку.
//
// Кроме того, что Фасад позволяет снизить общую сложность программы, он также 
// помогает вынести код, зависимый от внешней системы в единственное место.

// Признаки применения паттерна: Фасад угадывается в классе, который имеет 
// простой интерфейс, но делегирует основную часть работы другим классам. 
// Чаще всего, фасады сами следят за жизненным циклом объектов сложной системы.

// Применимость

// 1. Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.
//
//  Часто подсистемы усложняются по мере развития программы. Применение большинства 
//  паттернов приводит к появлению меньших классов, но в бóльшем количестве. Такую 
//  подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды, 
//  но вместе с тем, применять подсистему без настройки становится труднее. Фасад 
//  предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

// 2. Когда вы хотите разложить подсистему на отдельные слои.
//
//  Используйте фасады для определения точек входа на каждый уровень подсистемы. Если 
//  подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам 
//  обмениваться информацией только через фасады.


/**
 * Подсистема может принимать запросы либо от фасада, либо от клиента напрямую.
 * В любом случае, для Подсистемы Фасад – это еще один клиент, и он не является
 * частью Подсистемы.
 */
struct SubSystem1 
{
	string operation1() { return "S1:1"; }
	string operationN() { return "S1:N"; }
};

/**
 * Некоторые фасады могут работать с разными подсистемами одновременно.
 */
struct SubSystem2
{
	string operation1() { return "S2:1"; }
	string operationX() { return "S2:X"; }
};


/**
 * Класс Фасада предоставляет простой интерфейс для сложной логики одной или
 * нескольких подсистем. Фасад делегирует запросы клиентов соответствующим
 * объектам внутри подсистемы. Фасад также отвечает за управление их жизненным
 * циклом. Все это защищает клиента от нежелательной сложности подсистемы.
 */
class Facade
{
public:
	/**
   * В зависимости от потребностей вашего приложения вы можете предоставить
   * Фасаду существующие объекты подсистемы или заставить Фасад создать их
   * самостоятельно.
   */
	Facade()
		: m_ss1(make_unique<SubSystem1>())
		, m_ss2(make_unique<SubSystem2>())
	{}

	 /**
   * Методы Фасада удобны для быстрого доступа к сложной функциональности
   * подсистем. Однако клиенты получают только часть возможностей подсистемы.
   */
	string process()
	{
		string res;

		res += m_ss1->operation1();
		res += m_ss2->operation1();

		res += m_ss1->operationN();
		res += m_ss2->operationX();

		return res;
	}

private:
	const unique_ptr<SubSystem1> m_ss1;
	const unique_ptr<SubSystem2> m_ss2;
};

/**
 * Клиентский код работает со сложными подсистемами через простой интерфейс,
 * предоставляемый Фасадом. Когда фасад управляет жизненным циклом подсистемы,
 * клиент может даже не знать о существовании подсистемы. Такой подход позволяет
 * держать сложность под контролем.
 */
void ClientCode(Facade& facade)
{
	cout << "RESULT: " << facade.process() << endl;
}

int main()
{
	Facade facade;

	ClientCode(facade);

	return 0;
}